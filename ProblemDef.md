# 最优样本选择问题定义与算法实现

## 1. 问题定义

### 1.1 基本参数
- `m`: 总样本空间大小（45 ≤ m ≤ 54）
- `n`: 从m个样本中选择的样本数量（7 ≤ n ≤ 25，且 n ≤ m）
- `k`: 每个组的大小（4 ≤ k ≤ 7）
- `j`: j-group的大小（j ≤ k）
- `s`: 子集大小（3 ≤ s ≤ 7，且 s ≤ j）

具体j和s的关系如下：
- 当 j = 4 时，s = 3 或 4
- 当 j = 5 时，s = 3, 4 或 5
- 当 j = 6 时，s = 3, 4, 5 或 6
- 当 j = 7 时，s = 3, 4, 5, 6 或 7

### 1.2 输入样本选择
- 从m个总样本中随机选择n个样本作为有效样本集
- 所有的组合和覆盖都基于这n个选定的样本进行
- 样本编号从1开始，按顺序编号（如1-12对应A-L）

### 1.3 问题描述

#### Mode A（基本覆盖问题）
- **目标**: 在n个选定样本中，选择最少数量的k-组，使得每个j-group中至少有一个s-子集被某个选中的k-组覆盖
- **输入**: m, n, k, j, s, samples[n]
- **输出**: 一组k-组的集合
- **约束**: 
  - 每个k-组必须包含k个不同的元素
  - 每个j-group必须至少有一个s-子集被覆盖
  - 要求使用最少的k-组数量
  - 所有组合必须从选定的n个样本中产生

#### Mode B（多重覆盖问题）
- **目标**: 在n个选定样本中，选择最少数量的k-组，使得每个j-group中至少有N个不同的s-子集被覆盖
- **输入**: m, n, k, j, s, N, samples[n]
- **输出**: 一组k-组的集合
- **约束**:
  - 每个k-组必须包含k个不同的元素
  - 每个j-group必须至少有N个不同的s-子集被覆盖
  - 要求使用最少的k-组数量
  - 所有组合必须从选定的n个样本中产生

#### Mode C（权重覆盖问题）
- **目标**: 在n个选定样本中，选择最少数量的k-组，使得每个s-子集被覆盖的次数尽可能均匀
- **输入**: m, n, k, s, samples[n]
- **输出**: 一组k-组的集合
- **约束**:
  - 每个k-组必须包含k个不同的元素
  - 最小化不同s-子集被覆盖次数的方差
  - 所有组合必须从选定的n个样本中产生

## 2. 算法设计

### 2.1 Mode A 算法

#### 贪心策略
1. 预处理：
   - 生成所有可能的k-组
   - 生成所有可能的j-group
   - 对每个j-group生成其所有s-子集

2. 评分机制：
   - 新覆盖率：一个k-组能覆盖多少个尚未被覆盖的j-group
   - 稀有性：优先覆盖那些覆盖选项较少的j-group
   - 效率：新覆盖的j-group数量与组大小的比率

3. 选择过程：
   ```cpp
   while (存在未覆盖的j-group) {
       计算每个候选k-组的得分
       选择得分最高的k-组
       更新覆盖状态
   }
   ```

4. 优化策略：
   - 使用并行计算加速覆盖关系的预计算
   - 维护优先队列以快速选择最优组
   - 动态更新候选组的得分

### 2.2 Mode B 算法

#### 扩展贪心策略
1. 预处理：
   - 除基本预处理外，还需计算每个j-group的所有可能s-子集

2. 评分机制：
   - 新覆盖率：能为每个j-group新增多少个未覆盖的s-子集
   - 进度评估：优先考虑接近目标N的j-group
   - 均衡性：避免过度覆盖某些j-group

3. 选择过程：
   ```cpp
   while (存在未达到N个覆盖的j-group) {
       计算每个候选k-组的综合得分
       选择得分最高的k-组
       更新每个j-group的覆盖状态
   }
   ```

### 2.3 Mode C 算法

#### 均衡覆盖策略
1. 预处理：
   - 生成所有可能的k-组和s-子集
   - 计算初始覆盖矩阵

2. 评分机制：
   - 覆盖均衡性：评估添加某个组后覆盖次数的方差
   - 覆盖效率：新增覆盖与已有覆盖的比率
   - 补充性：与已选组的互补程度

3. 选择过程：
   ```cpp
   while (未达到覆盖均衡性要求) {
       计算添加每个候选组后的方差变化
       选择使方差最小的组
       更新覆盖状态和统计信息
   }
   ```

## 3. 实现细节

### 3.1 核心数据结构
```cpp
struct GroupScore {
    size_t index;
    int newCovered;       // 新覆盖的数量
    double necessity;     // 必要性分数
    double efficiency;    // 效率分数
};

struct DetailedSolution {
    std::vector<std::vector<int>> groups;
    int totalGroups;
    double coverageRatio;
    double computationTime;
    bool isOptimal;
    std::string message;
    Status status;
};
```

### 3.2 关键函数实现
```cpp
// 检查一个组是否包含另一个组
bool contains(const std::vector<int>& container, const std::vector<int>& subset);

// 计算组的得分
double calculateGroupScore(const std::vector<int>& group, const std::vector<bool>& covered);

// 验证解的正确性
bool verifySolution(const std::vector<int>& samples, int s, const Solution& solution);
```

### 3.3 优化技术
1. 并行计算
   - 使用多线程并行计算覆盖关系
   - 并行生成组合和评估候选组

2. 内存优化
   - 使用位图表示覆盖状态
   - 采用稀疏矩阵存储覆盖关系

3. 计算优化
   - 缓存中间结果
   - 增量更新评分
   - 提前终止无效搜索

## 4. 测试与验证

### 4.1 测试用例
1. 基本测试
   - 小规模完整性测试
   - 边界条件测试
   - 特殊输入测试

2. 性能测试
   - 大规模数据测试
   - 时间复杂度验证
   - 内存使用监控

### 4.2 验证方法
1. 正确性验证
   - 检查所有约束条件
   - 验证覆盖完整性
   - 对比已知最优解

2. 性能验证
   - 测量运行时间
   - 评估内存使用
   - 分析算法扩展性

## 5. 已知问题与改进方向

### 5.1 已知问题
1. 覆盖计算可能存在效率问题
2. 大规模数据下的内存消耗较大
3. 某些特殊情况下可能生成次优解

### 5.2 改进方向
1. 优化覆盖关系的计算方法
2. 改进内存管理策略
3. 引入启发式规则提高解的质量
4. 实现动态调整的评分机制 